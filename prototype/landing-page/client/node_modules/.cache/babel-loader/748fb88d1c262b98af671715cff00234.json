{"ast":null,"code":"!function (t) {\n  \"object\" == typeof module && \"undefined\" != typeof module.exports ? module.exports = t : t();\n}(function () {\n  (window.webpackJsonpFusionCharts = window.webpackJsonpFusionCharts || []).push([[8], {\n    702: function _(t, e, o) {\n      \"use strict\";\n\n      e.__esModule = !0, e.ZoomScatter = undefined;\n      var i,\n          n = o(703),\n          a = (i = n) && i.__esModule ? i : {\n        \"default\": i\n      };\n      e.ZoomScatter = a[\"default\"], e[\"default\"] = {\n        name: \"zoomscatter\",\n        type: \"package\",\n        requiresFusionCharts: !0,\n        extension: function extension(t) {\n          t.addDep(a[\"default\"]);\n        }\n      };\n    },\n    703: function _(t, e, o) {\n      \"use strict\";\n\n      e.__esModule = !0;\n      var i = c(o(414)),\n          n = c(o(704)),\n          a = o(118),\n          r = o(676),\n          s = o(125),\n          l = o(129);\n\n      function c(t) {\n        return t && t.__esModule ? t : {\n          \"default\": t\n        };\n      }\n\n      function h(t, e) {\n        if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n        t.prototype = Object.create(e && e.prototype, {\n          constructor: {\n            value: t,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : function (t, e) {\n          for (var o = Object.getOwnPropertyNames(e), i = 0; i < o.length; i++) {\n            var n = o[i],\n                a = Object.getOwnPropertyDescriptor(e, n);\n            a && a.configurable && t[n] === undefined && Object.defineProperty(t, n, a);\n          }\n        }(t, e));\n      }\n\n      (0, s.getDep)(\"redraphael\", \"plugin\").addSymbol(r.symbolList);\n\n      var g = function (t) {\n        function e() {\n          !function (t, e) {\n            if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, e);\n\n          var o = function (t, e) {\n            if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n          }(this, t.call(this));\n\n          return o.highlightEnabled = !1, o.isXY = !0, o.zoom = !0, o.zoomX = !0, o.zoomY = !0, o.defaultZeroPlaneHighlighted = !1, o;\n        }\n\n        return h(e, t), e.getName = function () {\n          return \"ZoomScatter\";\n        }, e.prototype.getName = function () {\n          return \"ZoomScatter\";\n        }, e.prototype.__setDefaultConfig = function () {\n          t.prototype.__setDefaultConfig.call(this);\n\n          var e = this.config;\n          e.friendlyName = \"ZoomScatter Chart\", e.defaultDatasetType = \"zoomscatter\", e.enablemousetracking = !0, e.animation = 0;\n        }, e.prototype.configureAttributes = function (e) {\n          var o,\n              i = this.config;\n          t.prototype.configureAttributes.call(this, e), o = this.getFromEnv(\"dataSource\").chart, i.stepZoom = 400 / (100 - (0, a.pluckNumber)(o.stepzoom, 25)), i.stepZoom <= 2 && (i.stepZoom = 1.9), i.showToolBarButtonToolText = (0, a.pluckNumber)(o.showtoolbarbuttontooltext, 1), i.btnResetChartToolText = (0, a.pluck)(o.btnresetcharttooltext, \"Reset Chart\"), i.btnZoomOutToolText = (0, a.pluck)(o.btnzoomouttooltext, \"Zoom out to previous level\"), i.btnZoomInToolText = (0, a.pluck)(o.btnzoomintooltext, \"<strong>Zoom in</strong><br/>Or double-click on plot to zoom-in\"), i.btnSelectZoomToolText = (0, a.pluck)(o.btnselectzoomtooltext, \"<strong>Select a region to zoom-in</strong><br/>Click to enable pan mode.\"), i.btnPanToolText = (0, a.pluck)(o.btnpantooltext, \"<strong>Drag to move across chart</strong><br/>Click to enable select-zoom mode.\");\n        }, e.includeInputOptions = function () {\n          return [\"DragPan\", \"DragZoomIn\", \"ZoomResetButton\", \"ZoomOutButton\", \"ZoomInButton\", \"DbTapZoom\", \"PinchZoom\"];\n        }, e.prototype.getInputConfigurations = function () {\n          var t = this,\n              e = t.config,\n              o = function o() {\n            t.addJob(\"spaceManage\", function () {\n              t._manageInteractiveSpace();\n            }, l.priorityList.configure);\n          };\n\n          return {\n            dragZoomIn: {\n              scaleX: !0,\n              scaleY: !0,\n              boxStyle: {\n                \"stroke-width\": 1,\n                stroke: \"red\",\n                fill: \"#00FF00\",\n                opacity: .2,\n                cursor: \"ne-resize\"\n              },\n              dragendFn: o,\n              tooltext: e.btnSelectZoomToolText,\n              zoomDecimalLimit: 2\n            },\n            zoomResetButton: {\n              tooltext: e.btnResetChartToolText,\n              hookFn: o\n            },\n            zoomOutButton: {\n              tooltext: e.btnZoomOutToolText,\n              hookFn: o\n            },\n            zoomInButton: {\n              tooltext: e.btnZoomInToolText,\n              stepzoom: e.stepZoom,\n              zoomDecimalLimit: 2,\n              hookFn: o\n            },\n            dragPan: {\n              tooltext: e.btnPanToolText\n            },\n            dbTapZoom: {\n              stepzoom: e.stepZoom,\n              zoomDecimalLimit: 2,\n              hookFn: o\n            },\n            pinchZoom: {\n              zoomDecimalLimit: 2\n            }\n          };\n        }, e.prototype._checkInvalidSpecificData = function () {\n          if (!this.getFromEnv(\"dataSource\").dataset) return !0;\n        }, e.prototype.getDatasets = function () {\n          var t = [];\n          return this.iterateComponents(function (e) {\n            e.getType && \"dataset\" === e.getType() && t.push(e);\n          }), t;\n        }, e.prototype.getDSdef = function () {\n          return n[\"default\"];\n        }, e.prototype.getDSGroupdef = function () {}, e;\n      }(i[\"default\"]);\n\n      g.prototype._manageInteractiveSpace = a._manageInteractiveSpace, e[\"default\"] = g;\n    },\n    704: function _(t, e, o) {\n      \"use strict\";\n\n      e.__esModule = !0;\n      var i = c(o(418)),\n          n = c(o(419)),\n          a = o(129),\n          r = o(118),\n          s = o(122),\n          l = c(o(215));\n\n      function c(t) {\n        return t && t.__esModule ? t : {\n          \"default\": t\n        };\n      }\n\n      function h(t, e) {\n        if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n        t.prototype = Object.create(e && e.prototype, {\n          constructor: {\n            value: t,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : function (t, e) {\n          for (var o = Object.getOwnPropertyNames(e), i = 0; i < o.length; i++) {\n            var n = o[i],\n                a = Object.getOwnPropertyDescriptor(e, n);\n            a && a.configurable && t[n] === undefined && Object.defineProperty(t, n, a);\n          }\n        }(t, e));\n      }\n\n      var g = window,\n          d = function d() {\n        this.hide();\n      },\n          u = Math.PI,\n          p = r.preDefStr.DEFAULT,\n          f = 2 * u,\n          m = function m(t, e) {\n        return t * e >= 0;\n      },\n          x = function x(t, e, o, i, n, a, r, s) {\n        var l, c, h, g, d, u, p, f, x, y;\n        return y = (l = i - e) * r + (h = t - o) * s + (d = o * e - t * i), 0 !== (x = l * n + h * a + d) && 0 !== y && m(x, y) ? 0 : (f = (c = s - a) * o + (g = n - r) * i + (u = r * a - n * s), 0 !== (p = c * t + g * e + u) && 0 !== f && m(p, f) ? 0 : (l * g - c * h, 1));\n      },\n          y = function y(t, e, o) {\n        if (!(isNaN(t.x) || isNaN(t.y) || isNaN(e.x) || isNaN(e.y))) return x(t.x, t.y, e.x, e.y, o.xMinWPad, o.yMaxWPad, o.xMaxWPad, o.yMaxWPad) || x(t.x, t.y, e.x, e.y, o.xMaxWPad, o.yMaxWPad, o.xMaxWPad, o.yMinWPad) || x(t.x, t.y, e.x, e.y, o.xMaxWPad, o.yMinWPad, o.xMinWPad, o.yMinWPad);\n      },\n          v = function v(t) {\n        var e = (t.config.axisRange.max - t.config.axisRange.min) / (t.getVisibleConfig().maxValue - t.getVisibleConfig().minValue);\n        return e = Math.round(1e3 * e) / 1e3;\n      },\n          b = function b(t) {\n        return [t - 1, t, t + 1];\n      },\n          P = function P(t, e, o) {\n        return t >= e && t <= o;\n      },\n          S = function S(t, e, o) {\n        return P(t, e, o) || P(t, o, e);\n      },\n          w = function w(t, e) {\n        return (e = parseFloat(e / 100)) < 0 ? e = 0 : e > 1 && (e = 1), t || (t = \"#FFFFFF\"), r.isIE && !r.hasSVG ? e ? t : \"transparent\" : (t = t.replace(/^#?([a-f0-9]+)/gi, \"$1\"), (t = (0, s.HEXtoRGB)(t))[3] = e.toString(), \"rgba(\" + t.join(\",\") + \")\");\n      },\n          k = function k(t) {\n        var e,\n            o,\n            i = [],\n            n = t.getVisibleConfig(),\n            a = n.maxValue - n.minValue,\n            r = n.minValue + a / 2,\n            s = t.config,\n            l = s.axisRange;\n        return e = Math.abs((r - (s.isReverse ? l.max : l.min)) / a), o = i.focusedGrid = Math.floor(e), i.push(o), e % 1 > .5 ? i.push(o + 1) : e % 1 < .5 && i.unshift(o - 1), i;\n      },\n          T = function (t) {\n        function e() {\n          return function (t, e) {\n            if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, e), function (t, e) {\n            if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !e || \"object\" != typeof e && \"function\" != typeof e ? t : e;\n          }(this, t.apply(this, arguments));\n        }\n\n        return h(e, t), e.prototype.getType = function () {\n          return \"dataset\";\n        }, e.prototype.getName = function () {\n          return \"zoomScatter\";\n        }, e.prototype.configureAttributes = function (e) {\n          t.prototype.configureAttributes.call(this, e);\n          var o,\n              i,\n              n,\n              a,\n              l,\n              c,\n              h,\n              g = this.config,\n              d = this.getFromEnv(\"chart\"),\n              u = d.config,\n              p = d.getFromEnv(\"dataSource\").chart,\n              f = (0, r.pluck)(e.anchorbordercolor, p.anchorbordercolor),\n              m = (0, s.getFirstColor)((0, r.pluck)(f, g.plotBorderColor)),\n              x = (0, r.pluckNumber)(e.anchorborderthickness, p.anchorborderthickness, f ? 1 : 0),\n              y = (0, s.getFirstColor)((0, r.pluck)(e.anchorbgcolor, e.color, p.anchorbgcolor, g.plotColor)),\n              v = (0, r.pluck)(e.anchoralpha, e.alpha, p.anchoralpha, r.HUNDREDSTRING),\n              b = (0, r.pluck)(e.anchorbgalpha, e.alpha, p.anchorbgalpha, r.HUNDREDSTRING),\n              P = {\n            color: g.lineColor,\n            alpha: g.lineAlpha\n          };\n          g.plotCosmetics = {\n            fillStyle: w(y, v * b / 100),\n            strokeStyle: w(m, v),\n            borderWidth: x,\n            lineWidth: g.lineThickness,\n            lineStrokeStyle: (0, r.toRaphaelColor)(P)\n          }, this.config.JSONData = e, g.anchorBorderThickness = (0, r.pluckNumber)(e.anchorborderthickness, p.anchorborderthickness, f ? 1 : 0), g.chunkSize = Math.floor(Math.min((e.data || []).length / 5, 5e4)), h = g.staticRadius = (0, r.pluckNumber)(p.staticradius, 0), g.radius = (0, r.pluckNumber)(e.radius, e.anchorradius, p.radius, p.anchorradius, h ? 3 : .5), c = g.showHoverEffect, o = (0, s.getFirstColor)((0, r.pluck)(e.plotfillhovercolor, e.hovercolor, p.plotfillhovercolor, p.hovercolor, g.anchorbgcolor)), i = (0, r.pluck)(e.plotfillhoveralpha, e.hoveralpha, p.plotfillhoveralpha, p.hoveralpha, r.HUNDREDSTRING), n = (0, s.getFirstColor)((0, r.pluck)(e.plotfillhovercolor, e.hovercolor, p.plotfillhovercolor, p.hovercolor, o)), l = (0, r.pluck)(e.plotfillhoveralpha, e.hoveralpha, p.plotfillhoveralpha, p.hoveralpha, r.HUNDREDSTRING), a = (0, r.pluckNumber)(e.borderhoverthickness, p.borderhoverthickness, 1), g.hoverCosmetics = {\n            showHoverEffect: c,\n            fill: w(o, i),\n            borderColor: w(n, l),\n            borderThickness: a\n          }, g.tooltip = {\n            toolTipVisible: u.showtooltip,\n            seriesNameInToolTip: u.seriesnameintooltip,\n            toolTipSepChar: u.tooltipsepchar\n          }, g.lastViewPort = {}, this.disableScrollBars(), this.setState(\"dirty\", !0);\n        }, e.prototype.hasDrawingRefChanged = function () {\n          var t,\n              e = this.getFromEnv(\"xAxis\"),\n              o = this.getFromEnv(\"yAxis\"),\n              i = this.config,\n              n = i.axisConfig = i.axisConfig || {},\n              a = v(e),\n              r = this.getFromEnv(\"chartConfig\"),\n              s = v(o);\n          return t = n.xZoomScale !== a || n.yZoomScale !== s || i.prevCanvasHeight !== r.canvasHeight || i.prevCanvasWidth !== r.canvasWidth, n.xZoomScale = a, n.yZoomScale = s, i.prevCanvasHeight = r.canvasHeight, i.prevCanvasWidth = r.canvasWidth, t;\n        }, e.prototype.saveScrollPos = function () {\n          var t = this.getFromEnv(\"xAxis\"),\n              e = this.getFromEnv(\"yAxis\"),\n              o = this.config,\n              i = o.axisConfig = o.axisConfig || {};\n          i.xScrollPos = t.config.apparentScrollPos, i.yScrollPos = e.config.apparentScrollPos;\n        }, e.prototype.disableScrollBars = function () {\n          var t = this.getFromEnv(\"xAxis\"),\n              e = this.getFromEnv(\"yAxis\");\n          t.setScrollType(\"none\"), e.setScrollType(\"none\");\n        }, e.prototype.calculateZoomedRadius = function () {\n          var t = this.config,\n              e = this.getFromEnv(\"chart\").config,\n              o = t.axisConfig;\n          t.zoomedRadius = Math.min(t.staticRadius ? t.radius : t.radius * Math.min(o.xZoomScale, o.yZoomScale), e.canvasWidth / 2, e.canvasHeight / 2);\n        }, e.prototype.setupKdTree = function () {\n          var t,\n              e,\n              o,\n              i = this,\n              r = i.components.data,\n              s = r.length,\n              l = [];\n\n          for (e = 0; e < s; ++e) {\n            o = (t = r[e]).config.setValue, isNaN(o.x) || isNaN(o.y) || (o.index = e, l.push({\n              x: o.x,\n              y: o.y,\n              index: e,\n              data: t,\n              r: 1\n            }));\n          }\n\n          i.addJob(\"kdtree\", function () {\n            i.dataTree = new n[\"default\"]().buildKdTree(l);\n          }, a.priorityList.kdTree);\n        }, e.prototype._getHoveredPlot = function (t, e) {\n          var o,\n              i,\n              n,\n              a = this.getFromEnv(\"xAxis\"),\n              r = this.getFromEnv(\"yAxis\");\n          if (i = a.getValue(t + a.getTranslation()), n = r.getValue(e + r.getTranslation()), o = this.dataTree && this.dataTree.getNeighbour({\n            x: i,\n            y: n,\n            options: this.zoomRadiusOb\n          }, !0)) return o.data.x = o.x, o.data.y = o.y, {\n            pointIndex: o.index || o.i,\n            hovered: !0,\n            pointObj: o.data\n          };\n        }, e.prototype._decideTooltipType = function (t, e) {\n          var o = this.getFromEnv(\"toolTipController\"),\n              i = this.config.currentToolTip,\n              n = this.components.data[t],\n              a = n && (n.config.finalTooltext || n.config.toolText),\n              r = e.originalEvent;\n          a && (i ? o.draw(r, a, i) : i = this.config.currentToolTip = o.draw(r, a));\n        }, e.prototype._firePlotEvent = function (t, e, o) {\n          var i,\n              n = this.getFromEnv(\"chart\"),\n              a = this.components,\n              r = this.getFromEnv(\"toolTipController\"),\n              s = a.data[e],\n              l = this.getFromEnv(\"paper\").canvas.style;\n          if (s) switch (i = s.config.setLink, t) {\n            case \"fc-mouseover\":\n              this._decideTooltipType(e, o), this.highlightPoint(this.config.showHoverEffect, s), n.plotEventHandler(this.getGraphicalElement(\"tracker\"), o, \"dataplotRollover\"), i && (l.cursor = \"pointer\");\n              break;\n\n            case \"fc-mouseout\":\n              r.hide(this.config.currentToolTip), i && (l.cursor = p), this.highlightPoint(!1), n.plotEventHandler(this.getGraphicalElement(\"tracker\"), o, \"dataplotRollout\");\n              break;\n\n            case \"fc-click\":\n              n.plotEventHandler(this.getGraphicalElement(\"tracker\"), o, \"dataplotClick\");\n              break;\n\n            case \"fc-mousemove\":\n              this._decideTooltipType(e, o);\n\n          }\n        }, e.prototype.highlightPoint = function (t, e) {\n          var o,\n              i = this.getFromEnv(\"chart\").config,\n              n = this.getFromEnv(\"animationManager\"),\n              a = this.getGraphicalElement(\"tracker\"),\n              r = this.getFromEnv(\"xAxis\"),\n              s = this.getFromEnv(\"yAxis\"),\n              l = this && this.config,\n              c = l && l.zoomedRadius || 0,\n              h = l && l.hoverCosmetics,\n              g = h && h.fill,\n              u = h && h.borderColor,\n              p = h && h.borderThickness,\n              f = {},\n              m = e && e.link;\n          t && (f = {\n            r: c,\n            fill: g,\n            stroke: u,\n            \"stroke-width\": p,\n            cx: r.getPixel(e.x),\n            cy: s.getPixel(e.y)\n          }), n.setAnimationState(t ? \"mouseover\" : \"mouseout\"), o = n.setAnimation({\n            el: a || \"circle\",\n            attr: t && f,\n            container: this.getContainer(\"plotGroup\"),\n            component: this,\n            doNotRemove: !0,\n            callback: !t && d\n          }), t && o.show(), a || this.addGraphicalElement(\"tracker\", o), e && o.data(\"eventArgs\", {\n            x: e.x,\n            y: e.y,\n            tooltip: e.config.toolText,\n            link: m\n          }), i.lastHoveredPoint = e, f.cursor = m ? \"pointer\" : \"\";\n        }, e.prototype.drawCommonElements = function () {}, e.prototype.animateCommonElements = function () {}, e.prototype.remove = function () {\n          t.prototype.remove.call(this), this._deleteGridImages();\n        }, e.prototype.drawPlots = function () {\n          var t,\n              e,\n              o,\n              i,\n              n,\n              a = this.getFromEnv(\"animationManager\"),\n              r = this.getFromEnv(\"xAxis\"),\n              s = this.getFromEnv(\"yAxis\"),\n              l = this.config,\n              c = this.getContainer(\"plotGroup\"),\n              h = this.getContainer(\"containerLine\"),\n              g = this.getContainer(\"containerPlot\"),\n              d = !1,\n              u = this.config.anchorBorderThickness;\n          this.saveScrollPos(), i = a.setAnimation({\n            el: h || \"group\",\n            attr: {\n              name: \"lineGroup\"\n            },\n            container: c,\n            component: this,\n            label: \"group\"\n          }), n = a.setAnimation({\n            el: g || \"group\",\n            attr: {\n              name: \"plotGroup\"\n            },\n            container: c,\n            component: this,\n            label: \"group\"\n          }), this.getState(\"visible\") ? (i.show(), n.show()) : (i.hide(), n.hide()), !h && this.addContainer(\"containerLine\", i), !g && this.addContainer(\"containerPlot\", n), (this.hasDrawingRefChanged() || this.wasLastDrawPixelated || this.getState(\"dirty\")) && (this.wasLastDrawPixelated = !1, this.calculateZoomedRadius(), t = v(r), e = v(s), o = l.radius * Math.min(t, e), this.zoomRadiusOb = {\n            rx: r.getValue(o + u) - r.getValue(0),\n            ry: s.getValue(0) - s.getValue(o + u)\n          }, this._deleteGridImages(), this._graphics._grid = {}, d = !0), this._gridDraw(d), this.setState(\"dirty\", !1);\n        }, e.prototype._deleteGridImages = function () {\n          var t,\n              e,\n              o,\n              i,\n              n,\n              a,\n              r,\n              s,\n              l = this.config,\n              c = this._graphics,\n              h = c._imagePool || (c._imagePool = []),\n              g = c._canvasPool || (c._canvasPool = []),\n              d = c._lineImagePool || (c._lineImagePool = []),\n              u = c._lineCanvasPool || (c._lineCanvasPool = []),\n              p = c._grid || [],\n              f = l._batchDrawTimers;\n          if (f && f.length) for (; f.length;) {\n            this.removeJob(f.shift());\n          }\n\n          for (a in p) {\n            if (s = p[a]) for (r in s) {\n              (n = s[r]) && n.drawState && ((t = n.image).attr({\n                src: \"\",\n                width: 0,\n                height: 0\n              }), h.push(t), delete n.image, i = n.canvas, g.push(i), delete n.canvas, delete n.ctx, (e = n.lineImage) && (e.attr({\n                src: \"\",\n                width: 0,\n                height: 0\n              }), d.push(e), delete n.lineImage, o = n.lineCanvas, u.push(o), delete n.lineCanvas, delete n.lineCtx));\n            }\n          }\n\n          delete c._grid;\n        }, e.prototype._gridDraw = function (t) {\n          var e = this,\n              o = e.config;\n          clearTimeout(o.timer), t ? e._gridManager() : o.timer = e.addJob(\"_gridManagerId\", function () {\n            e._gridManager();\n          }, a.priorityList.label);\n        }, e.prototype.getAllGrids = function () {\n          var t,\n              e,\n              o,\n              i,\n              n,\n              a,\n              r,\n              s,\n              l,\n              c = this.config,\n              h = this.getFromEnv(\"chart\").config,\n              g = this.getFromEnv(\"xAxis\"),\n              d = this.getFromEnv(\"yAxis\"),\n              u = k(g),\n              p = k(d),\n              f = b(u.focusedGrid),\n              m = b(p.focusedGrid),\n              x = [],\n              y = [],\n              P = 0,\n              S = 0,\n              w = this._graphics._grid,\n              T = {},\n              C = v(g),\n              E = v(d),\n              M = Math.ceil(E),\n              _ = Math.ceil(C),\n              F = Math.max(p.focusedGrid - 1, 0),\n              I = Math.min(p.focusedGrid + 1, M - 1),\n              N = Math.max(u.focusedGrid - 1, 0),\n              D = Math.min(u.focusedGrid + 1, _ - 1),\n              A = g.getAxisConfig(\"axisDimention\").axisLength || h.canvasWidth,\n              R = d.getAxisConfig(\"axisDimention\").axisLength || h.canvasHeight,\n              V = g.config,\n              L = d.config,\n              G = V.axisRange.min,\n              W = V.axisRange.max,\n              O = L.axisRange.min,\n              Z = L.axisRange.max,\n              z = c.radius * Math.min(C, E) + c.plotCosmetics.borderWidth,\n              B = Math.abs(z / (A * C / (g.config.axisRange.max - g.config.axisRange.min))),\n              H = Math.abs(z / (R * E / (d.config.axisRange.max - d.config.axisRange.min))),\n              j = d.getPixel(d.config.axisRange.max),\n              J = g.getPixel(g.config.axisRange.min);\n\n          for (w || (this.config.grids = w = {}), P = F; P <= I; ++P) {\n            for (w[P] = T = w[P] || {}, s = j + P * R, i = d.getValue(s), n = d.getValue(s + R), S = N; S <= D; ++S) {\n              a = 0 === S ? z : 0, r = S === _ - 1 ? z : 0, l = J + S * A - a, o = g.getValue(l), e = g.getValue(l + A + a + r), T[S] = t = T[S] || {\n                xPixel: l,\n                width: Math.abs(g.getPixel(e) - l),\n                yPixel: s,\n                height: d.getPixel(n) - s,\n                xLeftValue: o,\n                yTopValue: i,\n                xRightValue: e,\n                yBottomValue: n,\n                drawState: 0,\n                xMinWPad: Math.max(Math.min(o, e) - B, G),\n                yMinWPad: Math.max(Math.min(i, n) - H, O),\n                xMaxWPad: Math.min(Math.max(o, e) + B, W),\n                yMaxWPad: Math.min(Math.max(i, n) + H, Z),\n                i: P,\n                j: S\n              }, t.drawState || (~u.indexOf(S) && ~p.indexOf(P) ? x.push(t) : ~f.indexOf(S) && ~m.indexOf(P) && y.push(t));\n            }\n          }\n\n          return {\n            focused: x,\n            nearBy: y\n          };\n        }, e.prototype.allocatePosition = function () {\n          var t,\n              e,\n              o,\n              i,\n              n,\n              a = this.config,\n              r = this.components.data,\n              s = r.length,\n              l = this.getFromEnv(\"xAxis\"),\n              c = this.getFromEnv(\"yAxis\"),\n              h = a.zoomedRadius;\n\n          for (o = 0; o < s; o++) {\n            i = (n = r[o].config).setValue, t = l.getPixel(i.x), e = c.getPixel(i.y), n.props = {\n              element: {\n                attr: {\n                  polypath: [0, t, e, h || n.anchorProps.radius]\n                }\n              },\n              label: {\n                attr: {}\n              }\n            };\n          }\n        }, e.prototype._gridManager = function () {\n          var t,\n              e,\n              o = this;\n          t = o.getAllGrids(), o.config._drawGrid = t.focused, (t.focused.length || t.nearBy.length) && (o.config._drawGrid = t.focused, e = function e() {\n            o.config._drawGrid = t.nearBy, o._drawGridArr();\n          }, o._drawGridArr(e));\n        }, e.prototype._drawGridArr = function (t) {\n          var e,\n              o,\n              i,\n              n,\n              a,\n              r,\n              s,\n              l,\n              c,\n              h = this.config,\n              d = h.drawLine,\n              u = h._drawGrid,\n              p = [],\n              f = this.getFromEnv(\"animationManager\"),\n              m = this.getContainer(\"containerLine\"),\n              x = this.getContainer(\"containerPlot\"),\n              y = this.getFromEnv(\"xAxis\"),\n              b = this.getFromEnv(\"yAxis\"),\n              P = v(y),\n              S = v(b),\n              w = this._graphics._imagePool || [],\n              k = this._graphics._canvasPool || [],\n              T = this._graphics._lineImagePool || [],\n              C = this._graphics._lineCanvasPool || [],\n              E = h.plotCosmetics,\n              M = h.radius * Math.min(P, S);\n\n          if (u.length) {\n            for (; u.length;) {\n              l = (e = u.shift()).xPixel, c = e.yPixel, r = e.width, s = e.height, 2 !== e.drawState && (e.drawState = 2, d && (T.length && (e.lineImage = T.shift()), e.lineImage = f.setAnimation({\n                el: e.lineImage || \"image\",\n                attr: {\n                  x: l,\n                  y: c,\n                  width: r,\n                  height: s\n                },\n                container: m,\n                component: this,\n                label: \"image\"\n              }), C.length ? e.lineCanvas = i = C.shift() : e.lineCanvas = i = g.document.createElement(\"canvas\"), i.setAttribute(\"width\", r), i.setAttribute(\"height\", s), (a = e.lineCtx = i.getContext(\"2d\")).fillStyle = E.fillStyle, a.strokeStyle = E.lineStrokeStyle, a.lineWidth = E.lineWidth), w.length && (e.image = w.shift()), e.image = f.setAnimation({\n                el: e.image || \"image\",\n                attr: {\n                  x: l,\n                  y: c,\n                  width: r,\n                  height: s\n                },\n                container: x,\n                component: this,\n                label: \"image\"\n              }), k.length ? e.canvas = o = k.shift() : e.canvas = o = g.document.createElement(\"canvas\"), o.setAttribute(\"width\", r), o.setAttribute(\"height\", s), n = e.ctx = o.getContext(\"2d\"), M < 1 ? (n.strokeStyle = E.fillStyle, n.lineWidth = .5) : (n.fillStyle = E.fillStyle, n.strokeStyle = E.strokeStyle, n.lineWidth = E.borderWidth), p.push(e));\n            }\n\n            h._batchDrawindex = this.config.JSONData.data && this.config.JSONData.data.length - 1 || 0, this._drawGridArrBatch(p, t, !h.animation.enabled);\n          } else t && t();\n        }, e.prototype._drawGridArrBatch = function (t, e, o) {\n          var i,\n              n,\n              s,\n              l,\n              c,\n              h,\n              g,\n              d,\n              u,\n              p,\n              m,\n              x,\n              v,\n              b,\n              P,\n              w,\n              k,\n              T,\n              C,\n              E,\n              M,\n              _,\n              F,\n              I,\n              N = this,\n              D = N.config,\n              A = D.drawLine,\n              R = D.plotCosmetics,\n              V = D._batchDrawindex,\n              L = N.components.data,\n              G = V - D.chunkSize,\n              W = N.getFromEnv(\"xAxis\"),\n              O = N.getFromEnv(\"yAxis\"),\n              Z = N.getFromEnv(\"chart\"),\n              z = N.getFromEnv(\"animationManager\"),\n              B = Z.getFromEnv(\"dataSource\"),\n              H = D.JSONData,\n              j = D.zoomedRadius,\n              J = (0, r.pluckNumber)(H.showregressionline, Z.config.showregressionline, 0),\n              U = D._store || [],\n              K = R.lineWidth || j < 1;\n\n          for (J && (E = (0, r.toRaphaelColor)((0, r.pluck)(H.regressionlinecolor, B.chart.regressionlinecolor, D.anchorbordercolor, D.lineColor, \"fff000\")), M = (0, r.pluckNumber)(H.regressionlinethickness, B.chart.regressionlinethickness, 1), _ = (0, r.pluckNumber)(H.regressionlinealpha, B.chart.regressionlinealpha, 100) / 100), d = 0; d < t.length; d += 1) {\n            t[d].ctx.beginPath(), A && t[d].lineCtx.beginPath();\n          }\n\n          for (G = G <= 0 ? 0 : G; V >= G; V -= 1) {\n            if ((x = L[V] && L[V].config.setValue) && !isNaN(x.x) && !isNaN(x.y)) for (d = 0; d < t.length; d += 1) {\n              u = t[d], S(x.x, u.xMinWPad, u.xMaxWPad) && S(x.y, u.yMinWPad, u.yMaxWPad) ? (p = u.ctx, m = u.lineCtx, i = W.getPixel(x.x) - u.xPixel, n = O.getPixel(x.y) - u.yPixel, (g = U[i]) || (g = U[i] = {}), g[n] || (g[n] = !0, A && (v = V && L[V - 1].config.setValue, b = V < L.length - 1 && L[V + 1].config.setValue, !v || isNaN(v.x) || isNaN(v.y) || (F = W.getPixel(v.x) - u.xPixel, I = O.getPixel(v.y) - u.yPixel, m.moveTo(Math.round(F), Math.round(I)), m.lineTo(i, n), S(b.x, u.xMinWPad, u.xMaxWPad) && S(b.y, u.yMinWPad, u.yMaxWPad) || isNaN(b.x) || isNaN(b.y) || m.lineTo(W.getPixel(b.x) - u.xPixel, O.getPixel(b.y) - u.yPixel))), j < 1 ? (p.moveTo(i, n), p.lineTo(i + 1, n)) : (p.moveTo(i + j, n), p.arc(i, n, j, 0, f)))) : A && V && y(x, L[V - 1].config.setValue, u) && (v = L[V - 1].config.setValue, F = W.getPixel(v.x) - u.xPixel, I = O.getPixel(v.y) - u.yPixel, i = W.getPixel(x.x) - u.xPixel, n = O.getPixel(x.y) - u.yPixel, (m = u.lineCtx).moveTo(Math.round(F), Math.round(I)), m.lineTo(i, n));\n            }\n          }\n\n          for (d = 0; d < t.length; d += 1) {\n            (p = (u = t[d]).ctx).fill(), K && p.stroke(), p.closePath(), A && (m = u.lineCtx, K && m.stroke(), m.closePath());\n          }\n\n          if (D._batchDrawindex = V, V >= 0) {\n            if (!o) for (d = 0; d < t.length; d += 1) {\n              k = t[d].image, T = t[d].canvas, z.setAnimation({\n                el: k,\n                attr: {\n                  src: T.toDataURL(\"image/png\")\n                },\n                component: N\n              }), D.drawLine && (P = t[d].lineImage, w = t[d].lineCanvas, z.setAnimation({\n                el: P,\n                src: T.toDataURL(\"image/png\"),\n                component: N\n              }));\n            }\n            (D._batchDrawTimers || (D._batchDrawTimers = [])).push(N.addJob(\"_drawGridArrBatchID\", function () {\n              N.getFromEnv(\"chart\") && N._drawGridArrBatch(t, e, o);\n            }, a.priorityList.draw));\n          } else {\n            if (N.setupKdTree(), delete D._store, J) for (C = D.regressionPoints, d = 0; d < t.length; d += 1) {\n              k = (u = t[d]).image, T = u.canvas, p = u.ctx, C.length && (s = W.getPixel(C[0].x) - u.xPixel, c = O.getPixel(C[0].y) - u.yPixel, l = W.getPixel(C[1].x) - u.xPixel, h = O.getPixel(C[1].y) - u.yPixel, p.beginPath(), p.strokeStyle = E, p.lineWidth = M, p.globalAlpha = _, p.moveTo(s, c), p.lineTo(l, h), p.stroke(), p.closePath());\n            }\n\n            for (d = 0; d < t.length; d += 1) {\n              k = (u = t[d]).image, T = u.canvas, u.drawState = 1, z.setAnimation({\n                el: k,\n                attr: {\n                  src: T.toDataURL(\"image/png\")\n                },\n                component: N\n              }), A && (P = u.lineImage, w = u.lineCanvas, z.setAnimation({\n                el: P,\n                attr: {\n                  src: w.toDataURL(\"image/png\")\n                },\n                component: N\n              }));\n            }\n\n            e && e();\n          }\n        }, e.prototype.getRegressionPoints = function () {\n          var t,\n              e,\n              o = this.config.regressionPoints,\n              i = -Infinity,\n              n = Infinity,\n              a = -Infinity,\n              r = Infinity;\n\n          if (o && o.length) {\n            for (e = o.length, t = 0; t < e; t++) {\n              i = Math.max(i, o[t].x), n = Math.min(n, o[t].x), a = Math.max(a, o[t].y), r = Math.min(r, o[t].y);\n            }\n\n            return {\n              max: a,\n              min: r,\n              xMax: i,\n              xMin: n\n            };\n          }\n        }, e.prototype.show = function () {\n          var t = this.getContainer(\"containerLine\"),\n              e = this.getContainer(\"containerPlot\"),\n              o = this.getFromEnv(\"legend\");\n          o && o.getItem(this.config.legendItemId) && o.getItem(this.config.legendItemId).removeLegendState(\"hidden\"), this.setState(\"visible\", !0), t.show(), e.show(), this.setState(\"dirty\", !0);\n        }, e.prototype.setContainerVisibility = function () {}, e.prototype.draw = function () {\n          var t = this,\n              e = t.config,\n              o = t.getFromEnv(\"xAxis\"),\n              i = o.getPixel(0),\n              n = o.getPixel(1),\n              r = t.getFromEnv(\"groupMaxWidth\"),\n              s = e.drawn,\n              l = (t.getSkippingInfo && t.getSkippingInfo() || {}).skippingApplied;\n          r || (r = Math.abs(n - i), t.addToEnv(\"groupMaxWidth\", r)), !s && t.createContainer(), t.setContainerVisibility(!0), l && t.hidePlots(), t.drawPlots(), t.drawCommonElements && !t.config.skipCommonElements && t.drawCommonElements(), e.drawn ? t.drawLabel(void 0, void 0) : t.addJob(\"labelDrawID\", function () {\n            t.drawLabel(void 0, void 0);\n          }, a.priorityList.label), e.drawn = !0, t.removePlots();\n        }, e.prototype.hide = function () {\n          var t = this.getContainer(\"containerLine\"),\n              e = this.getContainer(\"containerPlot\"),\n              o = this.getFromEnv(\"legend\");\n          o && o.getItem(this.config.legendItemId) && o.getItem(this.config.legendItemId).setLegendState(\"hidden\"), t.hide(), e.hide(), this.setState(\"dirty\", !0), this.setState(\"visible\", !1);\n        }, e.prototype._addLegend = function () {\n          var t,\n              e,\n              o = this.getFromEnv(\"chart\"),\n              i = o.getFromEnv(\"dataSource\").chart,\n              n = o.getFromEnv(\"legend\"),\n              a = this.config,\n              l = this.config.JSONData,\n              c = (0, r.pluck)(l.anchorbordercolor, i.anchorbordercolor),\n              h = (0, s.getFirstColor)((0, r.pluck)(c, a.plotBorderColor)),\n              g = (0, s.getFirstColor)((0, r.pluck)(l.anchorbgcolor, l.color, i.anchorbgcolor, a.plotColor)),\n              d = (0, r.pluck)(l.anchoralpha, l.alpha, i.anchoralpha, r.HUNDREDSTRING),\n              u = (0, r.pluck)(l.anchorbgalpha, l.alpha, i.anchorbgalpha, r.HUNDREDSTRING),\n              p = w(g, d * u / 100),\n              f = w(h, d);\n          e = {\n            enabled: a.includeInLegend,\n            type: this.type,\n            anchorSide: 2,\n            label: (0, r.getFirstValue)(this.config.JSONData.seriesname)\n          }, a.includeinlegend ? ((t = n.getItem(this.config.legendItemId)) ? t.configure({\n            style: n.config.itemStyle,\n            hiddenStyle: n.config.itemHiddenStyle,\n            datasetVisible: n.config.datasetVisible,\n            hoverStyle: n.config.itemHoverStyle\n          }) : (this.config.legendItemId = n.createItem(this), t = n.getItem(this.config.legendItemId), this.addExtEventListener(\"fc-click\", function () {\n            t.itemClickFn();\n          }, t)), t.configure(e), t.setStateCosmetics(\"default\", {\n            symbol: {\n              fill: p,\n              stroke: f,\n              rawFillColor: g,\n              rawStrokeColor: a.anchorbordercolor,\n              \"stroke-width\": a.anchorBorderThickness\n            }\n          }), this.getState(\"visible\") ? t.removeLegendState(\"hidden\") : t.setLegendState(\"hidden\")) : this.config.legendItemId && n.disposeItem(this.config.legendItemId);\n        }, e.prototype._setConfigure = function () {\n          var t,\n              e,\n              o,\n              i,\n              n,\n              a,\n              s,\n              c,\n              h,\n              g,\n              d,\n              u,\n              p = -Infinity,\n              f = +Infinity,\n              m = p,\n              x = f,\n              y = f,\n              v = p,\n              b = this.components.data || (this.components.data = []),\n              P = this.getFromEnv(\"chart\"),\n              S = this.config,\n              w = this.config.JSONData,\n              k = P.getFromEnv(\"dataSource\").chart,\n              T = w.data || [],\n              C = T.length,\n              E = this.getFromEnv(\"number-formatter\"),\n              M = (0, r.parseUnsafeString)(k.yaxisname),\n              _ = (0, r.parseUnsafeString)(k.xaxisname),\n              F = S.lineDashed,\n              I = S.lineDashStyle,\n              N = (0, r.pluckNumber)(w.showregressionline, P.config.showregressionline, 0),\n              D = (0, r.pluckNumber)(w.showyonx, k.showyonx, 1),\n              A = S.parentYAxis,\n              R = S.toolTipSepChar,\n              V = S.seriesname;\n\n          for (t = 0; t < C; t += 1) {\n            i = T[t], (e = (o = b[t] || (b[t] = {})).config || (o.config = {})).setValue = n = {\n              x: E.getCleanValue(i.x),\n              y: E.getCleanValue(i.y),\n              index: t\n            }, v < n.x && (v = n.x, S.rightMostData = o), y > n.x && (y = n.x, S.leftMostData = o), m = Math.max(m, n.y), x = Math.min(x, n.y), S.showRegressionLine && this.pointValueWatcher(n.x, n.y, S.regressionObj), e.setLink = (0, r.pluck)(i.link), e.anchorProps = this._parseAnchorProperties(t), e.showValue = (0, r.pluckNumber)(i.showvalue, S.showValues), e.dashed = (0, r.pluckNumber)(i.dashed, F), e.color = (0, r.pluck)(i.color, S.lineColor), e.alpha = (0, r.pluck)(i.alpha, S.lineAlpha), e.dashStyle = e.dashed ? I : \"none\", e.toolTipValue = s = E.dataLabels(n.y, A), e.setDisplayValue = u = (0, r.parseUnsafeString)(i.displayvalue), g = e.formatedVal = (0, r.pluck)(i.toolTipValue, E.dataLabels(n.y, A)), d = E.xAxis(n.x), e.displayValue = (0, r.pluck)(u, s), e.setTooltext = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(i.tooltext, S.plotToolText))), S.showTooltip ? void 0 !== e.setTooltext ? (c = [4, 5, 6, 7, 8, 9, 10, 11], h = {\n              yaxisName: M,\n              xaxisName: _,\n              yDataValue: g,\n              xDataValue: d\n            }, a = (0, r.parseTooltext)(e.setTooltext, c, h, i, k, w)) : null === g ? a = !1 : (a = V ? V + R : r.BLANKSTRING, a += n.x ? d + R : r.BLANKSTRING, a += s) : a = !1, e.toolText = a, o ? o.graphics || (b[t].graphics = {}) : o = b[t] = {\n              graphics: {}\n            }, e.hoverEffects = this._parseHoverEffectOptions(o), e.anchorProps.isAnchorHoverRadius = e.hoverEffects.anchorRadius;\n          }\n\n          S.xMax = v, S.xMin = y, S.yMin = x, S.yMax = m, S.regressionPoints = N ? (0, l[\"default\"])(w.data.slice(), D)[1] : [], this.ErrorValueConfigure && this.ErrorValueConfigure();\n        }, e;\n      }(i[\"default\"]);\n\n      e[\"default\"] = T;\n    }\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}